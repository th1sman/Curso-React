{"ast":null,"code":"// creates a matcher function\nexport default function makeMatcher(makeRegexpFn = pathToRegexp) {\n  let cache = {}; // obtains a cached regexp version of the pattern\n\n  const getRegexp = pattern => cache[pattern] || (cache[pattern] = makeRegexpFn(pattern));\n\n  return (pattern, path) => {\n    const {\n      regexp,\n      keys\n    } = getRegexp(pattern || \"\");\n    const out = regexp.exec(path);\n    if (!out) return [false, null]; // formats an object with matched params\n\n    const params = keys.reduce((params, key, i) => {\n      params[key.name] = out[i + 1];\n      return params;\n    }, {});\n    return [true, params];\n  };\n} // escapes a regexp string (borrowed from path-to-regexp sources)\n// https://github.com/pillarjs/path-to-regexp/blob/v3.0.0/index.js#L202\n\nconst escapeRx = str => str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\"); // returns a segment representation in RegExp based on flags\n// adapted and simplified version from path-to-regexp sources\n\n\nconst rxForSegment = (repeat, optional, prefix) => {\n  let capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\";\n  if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\";\n  return capture + (optional ? \"?\" : \"\");\n};\n\nconst pathToRegexp = pattern => {\n  const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;\n  let match = null,\n      lastIndex = 0,\n      keys = [],\n      result = \"\";\n\n  while ((match = groupRx.exec(pattern)) !== null) {\n    const [_, segment, mod] = match; // :foo  [1]      (  )\n    // :foo? [0 - 1]  ( o)\n    // :foo+ [1 - ∞]  (r )\n    // :foo* [0 - ∞]  (ro)\n\n    const repeat = mod === \"+\" || mod === \"*\";\n    const optional = mod === \"?\" || mod === \"*\";\n    const prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0;\n    const prev = pattern.substring(lastIndex, match.index - prefix);\n    keys.push({\n      name: segment\n    });\n    lastIndex = groupRx.lastIndex;\n    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);\n  }\n\n  result += escapeRx(pattern.substring(lastIndex));\n  return {\n    keys,\n    regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\")\n  };\n};","map":{"version":3,"sources":["/home/jaime/dev/Curso-React/node_modules/wouter/matcher.js"],"names":["makeMatcher","makeRegexpFn","pathToRegexp","cache","getRegexp","pattern","path","regexp","keys","out","exec","params","reduce","key","i","name","escapeRx","str","replace","rxForSegment","repeat","optional","prefix","capture","groupRx","match","lastIndex","result","_","segment","mod","index","prev","substring","push","RegExp"],"mappings":"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","sourcesContent":["// creates a matcher function\nexport default function makeMatcher(makeRegexpFn = pathToRegexp) {\n  let cache = {};\n\n  // obtains a cached regexp version of the pattern\n  const getRegexp = (pattern) =>\n    cache[pattern] || (cache[pattern] = makeRegexpFn(pattern));\n\n  return (pattern, path) => {\n    const { regexp, keys } = getRegexp(pattern || \"\");\n    const out = regexp.exec(path);\n\n    if (!out) return [false, null];\n\n    // formats an object with matched params\n    const params = keys.reduce((params, key, i) => {\n      params[key.name] = out[i + 1];\n      return params;\n    }, {});\n\n    return [true, params];\n  };\n}\n\n// escapes a regexp string (borrowed from path-to-regexp sources)\n// https://github.com/pillarjs/path-to-regexp/blob/v3.0.0/index.js#L202\nconst escapeRx = (str) => str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n\n// returns a segment representation in RegExp based on flags\n// adapted and simplified version from path-to-regexp sources\nconst rxForSegment = (repeat, optional, prefix) => {\n  let capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\";\n  if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\";\n  return capture + (optional ? \"?\" : \"\");\n};\n\nconst pathToRegexp = (pattern) => {\n  const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;\n\n  let match = null,\n    lastIndex = 0,\n    keys = [],\n    result = \"\";\n\n  while ((match = groupRx.exec(pattern)) !== null) {\n    const [_, segment, mod] = match;\n\n    // :foo  [1]      (  )\n    // :foo? [0 - 1]  ( o)\n    // :foo+ [1 - ∞]  (r )\n    // :foo* [0 - ∞]  (ro)\n    const repeat = mod === \"+\" || mod === \"*\";\n    const optional = mod === \"?\" || mod === \"*\";\n    const prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0;\n\n    const prev = pattern.substring(lastIndex, match.index - prefix);\n\n    keys.push({ name: segment });\n    lastIndex = groupRx.lastIndex;\n\n    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);\n  }\n\n  result += escapeRx(pattern.substring(lastIndex));\n  return { keys, regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\") };\n};\n"]},"metadata":{},"sourceType":"module"}