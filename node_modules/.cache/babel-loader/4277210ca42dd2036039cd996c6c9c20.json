{"ast":null,"code":"import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\n/**\r\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\r\n */\n\nconst eventPopstate = \"popstate\";\nconst eventPushState = \"pushState\";\nconst eventReplaceState = \"replaceState\";\nexport const events = [eventPopstate, eventPushState, eventReplaceState];\nexport default (({\n  base = \"\"\n} = {}) => {\n  const [pathAndSearch, update] = useState(() => ({\n    path: currentPathname(base),\n    search: location.search\n  })); // @see https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\n\n  const prevHash = useRef(pathAndSearch.path + pathAndSearch.search);\n  useEffect(() => {\n    // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      const search = location.search;\n      const hash = pathname + search;\n\n      if (prevHash.current !== hash) {\n        prevHash.current = hash;\n        update({\n          path: pathname,\n          search: search\n        });\n      }\n    };\n\n    events.map(e => addEventListener(e, checkForUpdates)); // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n\n    checkForUpdates();\n    return () => events.map(e => removeEventListener(e, checkForUpdates));\n  }, [base]); // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n\n  const navigate = useCallback((to, {\n    replace = false\n  } = {}) => history[replace ? eventReplaceState : eventPushState](null, \"\", // handle nested routers and absolute paths\n  to[0] === \"~\" ? to.slice(1) : base + to), [base]);\n  return [pathAndSearch.path, navigate];\n}); // While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\n\nif (typeof history !== \"undefined\") {\n  for (const type of [eventPushState, eventReplaceState]) {\n    const original = history[type];\n\n    history[type] = function () {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n      dispatchEvent(event);\n      return result;\n    };\n  }\n}\n\nconst currentPathname = (base, path = location.pathname) => !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || \"/\" : \"~\" + path;","map":{"version":3,"sources":["C:/Users/Jaime/Desktop/Dev/Curso-React/node_modules/wouter/use-location.js"],"names":["useEffect","useRef","useState","useCallback","eventPopstate","eventPushState","eventReplaceState","events","base","pathAndSearch","update","path","currentPathname","search","location","prevHash","checkForUpdates","pathname","hash","current","map","e","addEventListener","removeEventListener","navigate","to","replace","history","slice","type","original","result","apply","arguments","event","Event","dispatchEvent","toLowerCase","indexOf","length"],"mappings":"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","sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\r\n\r\n/**\r\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\r\n */\r\nconst eventPopstate = \"popstate\";\r\nconst eventPushState = \"pushState\";\r\nconst eventReplaceState = \"replaceState\";\r\nexport const events = [eventPopstate, eventPushState, eventReplaceState];\r\n\r\nexport default ({ base = \"\" } = {}) => {\r\n  const [pathAndSearch, update] = useState(() => ({\r\n    path: currentPathname(base),\r\n    search: location.search,\r\n  })); // @see https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const prevHash = useRef(pathAndSearch.path + pathAndSearch.search);\r\n\r\n  useEffect(() => {\r\n    // this function checks if the location has been changed since the\r\n    // last render and updates the state only when needed.\r\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\r\n    // that's why we store the last pathname in a ref.\r\n    const checkForUpdates = () => {\r\n      const pathname = currentPathname(base);\r\n      const search = location.search;\r\n      const hash = pathname + search;\r\n\r\n      if (prevHash.current !== hash) {\r\n        prevHash.current = hash;\r\n        update({ path: pathname, search: search });\r\n      }\r\n    };\r\n\r\n    events.map((e) => addEventListener(e, checkForUpdates));\r\n\r\n    // it's possible that an update has occurred between render and the effect handler,\r\n    // so we run additional check on mount to catch these updates. Based on:\r\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\r\n    checkForUpdates();\r\n\r\n    return () => events.map((e) => removeEventListener(e, checkForUpdates));\r\n  }, [base]);\r\n\r\n  // the 2nd argument of the `useLocation` return value is a function\r\n  // that allows to perform a navigation.\r\n  //\r\n  // the function reference should stay the same between re-renders, so that\r\n  // it can be passed down as an element prop without any performance concerns.\r\n  const navigate = useCallback(\r\n    (to, { replace = false } = {}) =>\r\n      history[replace ? eventReplaceState : eventPushState](\r\n        null,\r\n        \"\",\r\n        // handle nested routers and absolute paths\r\n        to[0] === \"~\" ? to.slice(1) : base + to\r\n      ),\r\n    [base]\r\n  );\r\n\r\n  return [pathAndSearch.path, navigate];\r\n};\r\n\r\n// While History API does have `popstate` event, the only\r\n// proper way to listen to changes via `push/replaceState`\r\n// is to monkey-patch these methods.\r\n//\r\n// See https://stackoverflow.com/a/4585031\r\nif (typeof history !== \"undefined\") {\r\n  for (const type of [eventPushState, eventReplaceState]) {\r\n    const original = history[type];\r\n\r\n    history[type] = function () {\r\n      const result = original.apply(this, arguments);\r\n      const event = new Event(type);\r\n      event.arguments = arguments;\r\n\r\n      dispatchEvent(event);\r\n      return result;\r\n    };\r\n  }\r\n}\r\n\r\nconst currentPathname = (base, path = location.pathname) =>\r\n  !path.toLowerCase().indexOf(base.toLowerCase())\r\n    ? path.slice(base.length) || \"/\"\r\n    : \"~\" + path;\r\n"]},"metadata":{},"sourceType":"module"}